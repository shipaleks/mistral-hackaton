<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eidetic</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
    <style>
      :root {
        --mistral-ink: #23262c;
        --mistral-paper: #faf8f2;
        --mistral-orange: #ff7043;
        --mistral-yellow: #ffca28;
        --mistral-green: #14c985;
        --mistral-blue: #338df5;
        --mistral-brown: #5d4037;

        --bg: var(--mistral-paper);
        --panel: #fffdf9;
        --line: #d9d6cc;
        --ink: var(--mistral-ink);
        --muted: #66635e;
        --accent: var(--mistral-orange);
        --accent-soft: #ffefe9;
        --ok: var(--mistral-green);
        --ok-soft: #e8fff6;
        --warn: var(--mistral-yellow);
        --warn-soft: #fff9df;
        --danger: #d43f35;
        --danger-soft: #fff0ef;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        color: var(--ink);
        background: radial-gradient(circle at top left, #fff2ea 0%, var(--bg) 45%, #f4f3ed 100%);
        font-family: "Inter", "Avenir Next", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }

      .layout {
        min-height: 100vh;
        display: grid;
        grid-template-columns: 320px 1fr;
      }

      .sidebar {
        border-right: 1px solid var(--line);
        background: #f7f4ec;
        padding: 16px;
      }

      .main {
        padding: 16px;
        display: grid;
        gap: 12px;
        align-content: start;
      }

      .card {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 12px;
      }

      h1,
      h2,
      h3,
      h4,
      p {
        margin: 0;
      }

      h1 {
        font-size: 24px;
      }

      h2 {
        font-size: 18px;
      }

      h3 {
        font-size: 16px;
      }

      .brand {
        display: grid;
        gap: 6px;
        margin-bottom: 12px;
      }

      .muted {
        color: var(--muted);
        font-size: 13px;
      }

      .pill-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .pill {
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 4px 8px;
        font-size: 11px;
        background: #fff;
        color: var(--muted);
      }

      .pill.ok {
        border-color: var(--ok);
        background: var(--ok-soft);
        color: #0f7b53;
      }

      .pill.warn {
        border-color: var(--warn);
        background: var(--warn-soft);
        color: #7f6200;
      }

      .pill.error {
        border-color: var(--danger);
        background: var(--danger-soft);
        color: #8f1f18;
      }

      .form {
        display: grid;
        gap: 8px;
      }

      label {
        display: grid;
        gap: 6px;
        font-size: 12px;
        color: var(--muted);
      }

      input,
      textarea {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        color: var(--ink);
        padding: 8px;
        font-size: 14px;
        font-family: inherit;
      }

      textarea {
        min-height: 90px;
        resize: vertical;
      }

      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      button {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        color: var(--ink);
        padding: 8px 12px;
        font-size: 13px;
        cursor: pointer;
      }

      button.primary {
        border-color: var(--accent);
        background: var(--accent);
        color: #fff;
      }

      button.warn {
        border-color: var(--warn);
        background: var(--warn-soft);
        color: #6f5700;
      }

      button.danger {
        border-color: var(--danger);
        background: var(--danger-soft);
        color: #8f1f18;
      }

      button.active {
        border-color: var(--mistral-blue);
        color: #0b57b7;
        box-shadow: inset 0 0 0 1px var(--mistral-blue);
      }

      .spinner {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 2px solid rgba(255, 255, 255, 0.4);
        border-top-color: #fff;
        display: inline-block;
        margin-right: 6px;
        animation: spin 0.8s linear infinite;
        vertical-align: -2px;
      }

      button:not(.primary) .spinner {
        border-color: rgba(35, 38, 44, 0.2);
        border-top-color: var(--mistral-ink);
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .status {
        min-height: 18px;
        font-size: 12px;
        color: var(--muted);
        white-space: pre-wrap;
      }

      .status.error {
        color: var(--danger);
      }

      .projects-list {
        margin-top: 10px;
        display: grid;
        gap: 8px;
        max-height: calc(100vh - 320px);
        overflow: auto;
      }

      .project-item {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        padding: 10px;
        cursor: pointer;
        display: grid;
        gap: 6px;
      }

      .project-item.active {
        border-color: var(--accent);
        box-shadow: inset 0 0 0 1px var(--accent);
      }

      .project-title {
        font-size: 13px;
        font-weight: 600;
        line-height: 1.35;
        word-break: break-word;
      }

      .project-meta {
        font-size: 11px;
        color: var(--muted);
        line-height: 1.35;
      }

      .flow-head {
        display: grid;
        gap: 8px;
      }

      .flow-top {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        align-items: flex-start;
      }

      .flow-steps {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
      }

      .step {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        padding: 10px;
        display: grid;
        gap: 8px;
      }

      .step small {
        color: var(--muted);
        font-size: 12px;
      }

      .talk-layout {
        display: grid;
        grid-template-columns: 1fr 140px;
        gap: 10px;
        align-items: center;
      }

      .talk-link {
        font-size: 13px;
        word-break: break-all;
        color: #17335f;
      }

      .qr {
        width: 140px;
        height: 140px;
        border: 1px solid var(--line);
        border-radius: 10px;
        object-fit: contain;
        background: #fff;
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 8px;
      }

      .metric {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        padding: 8px;
      }

      .metric .k {
        color: var(--muted);
        font-size: 11px;
      }

      .metric .v {
        margin-top: 3px;
        font-size: 18px;
        font-weight: 700;
      }

      .graph-wrap {
        margin-top: 10px;
        display: grid;
        grid-template-columns: minmax(0, 1fr) 320px;
        gap: 10px;
      }

      .graph-canvas {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: #fff;
        width: 100%;
        height: 520px;
      }

      .graph-side {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: #fff;
        padding: 10px;
        display: grid;
        gap: 10px;
        align-content: start;
        max-height: 520px;
        overflow: auto;
      }

      .graph-rule {
        border-left: 3px solid var(--accent);
        background: var(--accent-soft);
        border-radius: 8px;
        padding: 8px;
        font-size: 12px;
        line-height: 1.45;
      }

      .mini-list {
        display: grid;
        gap: 6px;
      }

      .mini-card {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        padding: 8px;
        font-size: 12px;
        line-height: 1.45;
        overflow-wrap: anywhere;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
      }

      .legend-dot {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .legend-dot::before {
        content: "";
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: currentColor;
      }

      .report-wrap {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: #fff;
        padding: 8px;
        height: 330px;
        max-height: 330px;
        overflow: auto;
      }

      .report-wrap pre {
        margin: 0;
        white-space: pre-wrap;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      details {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        padding: 8px;
        margin-bottom: 8px;
      }

      summary {
        cursor: pointer;
        font-weight: 600;
      }

      .danger-box {
        border: 1px solid var(--danger);
        background: var(--danger-soft);
        color: #7f1d1d;
        border-radius: 10px;
        padding: 8px;
        font-size: 12px;
        line-height: 1.45;
      }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }

      @media (max-width: 1220px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .sidebar {
          border-right: 0;
          border-bottom: 1px solid var(--line);
        }

        .flow-steps {
          grid-template-columns: 1fr;
        }

        .metrics {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .graph-wrap {
          grid-template-columns: 1fr;
        }

        .graph-canvas {
          height: 460px;
        }

        .graph-side {
          max-height: 340px;
        }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <h1>Eidetic</h1>
          <p class="muted">Create project, run interviews, review evidence map, generate report.</p>
        </div>

        <div class="card">
          <h3>Create Project</h3>
          <div class="form" style="margin-top:8px;">
            <label>
              Research question
              <textarea id="researchQuestion">What factors shape your experience with this topic?</textarea>
            </label>
            <div class="row">
              <button class="primary" id="createProjectBtn">Create project</button>
            </div>
            <div class="status" id="createStatus"></div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <h3>Projects</h3>
          <div id="projectsList" class="projects-list"></div>
        </div>
      </aside>

      <main class="main">
        <section class="card flow-head">
          <div class="flow-top">
            <div>
              <h2 id="projectTitle">Select or create a project</h2>
              <p class="muted" id="projectQuestion">Research question will appear here.</p>
            </div>
            <div class="row">
              <span class="pill" id="projectStatusPill">status: draft</span>
              <button id="reloadBtn">Reload state</button>
              <button id="stopBtn">Stop project</button>
              <button class="danger" id="deleteBtn">Delete project</button>
            </div>
          </div>

          <div class="flow-steps">
            <article class="step">
              <strong>1. Start Research</strong>
              <small>Generate first script and sync prompt to ElevenLabs.</small>
              <label>
                Agent ID (optional override)
                <input id="agentId" placeholder="agent_xxx" />
              </label>
              <div class="row">
                <button class="primary" id="startBtn">Start research</button>
              </div>
            </article>

            <article class="step">
              <strong>2. Interview Link</strong>
              <small>Share this link or QR. After a call ends, evidence appears automatically.</small>
              <div id="talkBlock" style="display:none;" class="talk-layout">
                <div>
                  <div class="talk-link" id="talkLink"></div>
                  <div class="row" style="margin-top:8px;">
                    <button id="openTalkBtn">Open interview link</button>
                  </div>
                </div>
                <img id="qrImg" class="qr" alt="Interview QR code" />
              </div>
              <div class="muted" id="talkPlaceholder">Start project first to generate interview link and QR.</div>
            </article>

            <article class="step">
              <strong>3. Finish</strong>
              <small>Generate a report from ingested evidence.</small>
              <div class="row">
                <button class="warn" id="finishBtn">Finish & generate report</button>
              </div>
              <div class="danger-box" id="ingestionHint">Waiting for first transcript via webhook.</div>
            </article>
          </div>

          <div class="status" id="controlStatus"></div>
        </section>

        <section class="card">
          <div class="row" style="justify-content:space-between; align-items:flex-start;">
            <div>
              <h2>Evidence Map</h2>
              <p class="muted" style="margin-top:4px;" id="graphDescription">
                Hypothesis Map: hypotheses are blocks, evidence nodes attach as supports (green) or contradicts (red).
              </p>
            </div>
            <div class="row">
              <button id="openFullscreenBtn">Open Fullscreen</button>
              <button id="modeHypothesisBtn" class="active">Hypothesis Map</button>
              <button id="modeNetworkBtn">Evidence Network</button>
            </div>
          </div>

          <div class="metrics" id="metrics" style="margin-top:10px;"></div>

          <div class="graph-wrap">
            <div>
              <svg id="graph" class="graph-canvas"></svg>
              <div class="legend" id="graphLegend"></div>
            </div>
            <aside class="graph-side">
              <div class="graph-rule" id="graphSummary">No evidence yet.</div>
              <div>
                <h4>Selected Item</h4>
                <div class="mini-list" id="selectedEvidence"></div>
              </div>
              <div>
                <h4>Research Progress</h4>
                <div class="mini-list" id="overlayList"></div>
              </div>
            </aside>
          </div>
        </section>

        <section class="card">
          <div class="row" style="justify-content:space-between; align-items:center;">
            <h2>Report</h2>
            <label style="display:flex; align-items:center; gap:6px; color:var(--ink); font-size:12px;">
              <input id="rawToggle" type="checkbox" style="width:auto;" />
              Raw markdown
            </label>
          </div>
          <div class="status" id="reportStatus" style="margin-top:8px;"></div>
          <div class="report-wrap" id="reportView"></div>
        </section>
      </main>
    </div>

    <script>
      const state = {
        cards: [],
        selectedProjectId: null,
        selectedProject: null,
        hypothesisMap: null,
        visualMode: "hypothesis",
        sse: null,
        sseConnected: false,
        cardsTimer: null,
        pollingTimer: null,
        refreshDebounce: null,
        actionTimeout: null,
        graph: {
          svg: null,
          gLinks: null,
          gNodes: null,
          gOverlays: null,
          gEmpty: null,
          simulation: null,
          nodePositions: new Map(),
          selectedNodeId: null,
          nodeById: new Map(),
          edges: [],
        },
      };

      const els = {
        researchQuestion: document.getElementById("researchQuestion"),
        createProjectBtn: document.getElementById("createProjectBtn"),
        createStatus: document.getElementById("createStatus"),
        projectsList: document.getElementById("projectsList"),
        projectTitle: document.getElementById("projectTitle"),
        projectQuestion: document.getElementById("projectQuestion"),
        projectStatusPill: document.getElementById("projectStatusPill"),
        reloadBtn: document.getElementById("reloadBtn"),
        controlStatus: document.getElementById("controlStatus"),
        agentId: document.getElementById("agentId"),
        startBtn: document.getElementById("startBtn"),
        finishBtn: document.getElementById("finishBtn"),
        stopBtn: document.getElementById("stopBtn"),
        deleteBtn: document.getElementById("deleteBtn"),
        talkBlock: document.getElementById("talkBlock"),
        talkLink: document.getElementById("talkLink"),
        openTalkBtn: document.getElementById("openTalkBtn"),
        qrImg: document.getElementById("qrImg"),
        talkPlaceholder: document.getElementById("talkPlaceholder"),
        ingestionHint: document.getElementById("ingestionHint"),
        metrics: document.getElementById("metrics"),
        graph: document.getElementById("graph"),
        graphSummary: document.getElementById("graphSummary"),
        graphDescription: document.getElementById("graphDescription"),
        graphLegend: document.getElementById("graphLegend"),
        openFullscreenBtn: document.getElementById("openFullscreenBtn"),
        modeHypothesisBtn: document.getElementById("modeHypothesisBtn"),
        modeNetworkBtn: document.getElementById("modeNetworkBtn"),
        selectedEvidence: document.getElementById("selectedEvidence"),
        overlayList: document.getElementById("overlayList"),
        reportStatus: document.getElementById("reportStatus"),
        reportView: document.getElementById("reportView"),
        rawToggle: document.getElementById("rawToggle"),
      };

      function escapeHtml(text) {
        return String(text || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;");
      }

      function setStatus(el, text, isError = false) {
        el.textContent = text;
        el.classList.toggle("error", Boolean(isError));
      }

      function nowTimeLabel() {
        return new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
      }

      function setButtonBusy(button, isBusy) {
        if (!button) return;
        if (!button.dataset.defaultText) {
          button.dataset.defaultText = button.textContent || "";
        }
        if (isBusy) {
          button.dataset.prevDisabled = button.disabled ? "1" : "0";
          button.disabled = true;
          button.innerHTML = '<span class="spinner"></span>Working...';
          return;
        }
        button.innerHTML = escapeHtml(button.dataset.defaultText);
        button.disabled = button.dataset.prevDisabled === "1";
        delete button.dataset.prevDisabled;
      }

      async function runAction({ button, statusEl, actionName, fn }) {
        setButtonBusy(button, true);
        setStatus(statusEl, `${actionName} started at ${nowTimeLabel()}`);
        if (state.actionTimeout) clearTimeout(state.actionTimeout);
        state.actionTimeout = setTimeout(() => {
          setStatus(statusEl, `${actionName}: still processing...`);
        }, 8000);
        try {
          const result = await fn();
          setStatus(statusEl, `${actionName} completed at ${nowTimeLabel()}`);
          return result;
        } catch (error) {
          setStatus(statusEl, error.message || String(error), true);
          return null;
        } finally {
          if (state.actionTimeout) clearTimeout(state.actionTimeout);
          setButtonBusy(button, false);
          if (state.selectedProject) renderProject(state.selectedProject);
        }
      }

      function toPct(value) {
        return `${Math.round((Number(value) || 0) * 100)}%`;
      }

      function statusColor(status) {
        if (status === "done") return "var(--ok)";
        if (status === "reporting") return "#a56c00";
        if (status === "running") return "var(--mistral-blue)";
        return "#6b7280";
      }

      function statusClass(status) {
        if (status === "done") return "ok";
        if (status === "reporting") return "warn";
        return "";
      }

      async function api(path, options = {}) {
        const response = await fetch(path, {
          headers: { "Content-Type": "application/json", ...(options.headers || {}) },
          ...options,
        });
        const text = await response.text();
        let data;
        try {
          data = text ? JSON.parse(text) : null;
        } catch {
          data = text;
        }
        if (!response.ok) {
          throw new Error(`${response.status} ${response.statusText}: ${typeof data === "string" ? data : JSON.stringify(data)}`);
        }
        return data;
      }

      async function refreshCards({ silent = false } = {}) {
        try {
          const cards = await api("/api/projects/cards");
          state.cards = Array.isArray(cards) ? cards : [];

          if (state.selectedProjectId) {
            const exists = state.cards.some((card) => card.id === state.selectedProjectId);
            if (!exists) {
              state.selectedProjectId = state.cards[0] ? state.cards[0].id : null;
            }
          } else if (state.cards[0]) {
            state.selectedProjectId = state.cards[0].id;
          }

          renderCards();

          if (!silent && state.selectedProjectId && !state.selectedProject) {
            await selectProject(state.selectedProjectId, { silent: true });
          }
        } catch (error) {
          if (!silent) {
            setStatus(els.controlStatus, error.message, true);
          }
        }
      }

      function renderCards() {
        els.projectsList.innerHTML = "";
        if (!state.cards.length) {
          const empty = document.createElement("div");
          empty.className = "project-item";
          empty.innerHTML = '<div class="project-title">No projects yet</div><div class="project-meta">Create the first project from the panel above.</div>';
          els.projectsList.appendChild(empty);
          return;
        }

        for (const card of state.cards) {
          const item = document.createElement("div");
          item.className = `project-item${card.id === state.selectedProjectId ? " active" : ""}`;
          item.innerHTML = `
            <div class="project-title">${escapeHtml(card.id)}</div>
            <div class="project-meta">
              <div><strong style="color:${statusColor(card.status)};">${escapeHtml(card.status)}</strong>${card.report_stale ? " - stale report" : ""}</div>
              <div>${card.interviews_count} interview(s), ${card.evidence_count} evidence</div>
              <div>convergence ${toPct(card.convergence_score)} - novelty ${toPct(card.novelty_rate)}</div>
            </div>
          `;
          item.onclick = () => selectProject(card.id);
          els.projectsList.appendChild(item);
        }
      }

      async function selectProject(projectId, { silent = false } = {}) {
        state.selectedProjectId = projectId;
        renderCards();
        await loadProject(projectId, { silent });
        connectSSE(projectId);
      }

      async function loadProject(projectId, { silent = false } = {}) {
        if (!projectId) return;
        try {
          const project = await api(`/api/projects/${encodeURIComponent(projectId)}`);
          state.selectedProject = project;
          state.hypothesisMap = await api(`/api/projects/${encodeURIComponent(projectId)}/visualization/hypothesis-map`);
          renderProject(project);
          if (!silent) {
            setStatus(els.controlStatus, `Loaded project ${project.id}`);
          }
        } catch (error) {
          setStatus(els.controlStatus, error.message, true);
        }
      }

      function renderProject(project) {
        els.projectTitle.textContent = project.id;
        els.projectQuestion.textContent = project.research_question || "";
        els.projectStatusPill.textContent = `status: ${project.status}`;
        els.projectStatusPill.className = `pill ${statusClass(project.status)}`.trim();
        els.reloadBtn.disabled = false;
        els.openFullscreenBtn.disabled = false;
        els.stopBtn.disabled = !["running", "reporting"].includes(project.status);
        els.deleteBtn.disabled = false;

        renderIngestionHint(project);
        renderTalk(project);
        renderMetrics(project);
        renderGraph(project);
        renderReport(project);
      }

      function renderIngestionHint(project) {
        const interviewsCount = (project.interview_store || []).length;
        const evidenceCount = (project.evidence_store || []).length;
        const hasData = interviewsCount > 0 && evidenceCount > 0;

        if (hasData) {
          els.ingestionHint.style.borderColor = "var(--ok)";
          els.ingestionHint.style.background = "var(--ok-soft)";
          els.ingestionHint.style.color = "#0f7b53";
          els.ingestionHint.textContent = `Webhook ingestion OK: ${interviewsCount} interview(s), ${evidenceCount} evidence item(s). prompt safety: ${project.prompt_safety_status || "ok"}.`;
          els.finishBtn.disabled = false;
          return;
        }

        els.ingestionHint.style.borderColor = "var(--danger)";
        els.ingestionHint.style.background = "var(--danger-soft)";
        els.ingestionHint.style.color = "#7f1d1d";
        els.ingestionHint.textContent = "No interview transcript ingested yet. Complete one call and wait for webhook delivery before finishing.";
        els.finishBtn.disabled = true;
      }

      function renderTalk(project) {
        const talk = String(project.talk_to_link || "").trim();
        if (!talk) {
          els.talkBlock.style.display = "none";
          els.talkPlaceholder.style.display = "block";
          els.talkLink.textContent = "";
          els.qrImg.removeAttribute("src");
          return;
        }
        els.talkBlock.style.display = "grid";
        els.talkPlaceholder.style.display = "none";
        els.talkLink.textContent = talk;
        els.openTalkBtn.onclick = () => window.open(talk, "_blank", "noopener,noreferrer");
        els.qrImg.src = `/api/projects/${encodeURIComponent(project.id)}/qrcode?ts=${Date.now()}`;
      }

      function renderMetrics(project) {
        const activePropositions = (project.proposition_store || []).filter((p) => !["weak", "merged"].includes(p.status)).length;
        const progress = state.hypothesisMap?.progress_snapshot || {};
        const metrics = [
          ["Participants", String((project.interview_store || []).length)],
          ["Evidence", String((project.evidence_store || []).length)],
          ["Active hypotheses", String(activePropositions)],
          ["New hypotheses (latest)", String(progress.new_hypotheses_latest_interview || 0)],
          ["Total hypotheses", String(progress.total_hypotheses || (project.proposition_store || []).length)],
          ["Convergence", toPct(project.metrics?.convergence_score)],
          ["Novelty", toPct(project.metrics?.novelty_rate)],
        ];
        els.metrics.innerHTML = metrics
          .map(([k, v]) => `<div class="metric"><div class="k">${escapeHtml(k)}</div><div class="v">${escapeHtml(v)}</div></div>`)
          .join("");
      }

      function tokenize(value) {
        const text = String(value || "").toLowerCase();
        let matches = [];
        try {
          matches = text.match(/[\p{L}\p{N}]{2,}/gu) || [];
        } catch {
          matches = text.split(/[^a-z0-9а-яё]+/).filter((x) => x.length > 1);
        }
        return new Set(matches);
      }

      function jaccard(setA, setB) {
        if (!setA.size && !setB.size) return 0;
        let intersection = 0;
        for (const item of setA) {
          if (setB.has(item)) intersection += 1;
        }
        return intersection / ((setA.size + setB.size - intersection) || 1);
      }

      function propositionColor(prop) {
        if (["weak", "merged"].includes(prop.status)) return "#9ca3af";
        if ((prop.confidence || 0) < 0.35) return "#dc2626";
        if ((prop.confidence || 0) < 0.7) return "#ffca28";
        return "#14c985";
      }

      function ensureGraphInitialized() {
        if (state.graph.svg) return;
        const svg = d3.select(els.graph);
        state.graph.svg = svg;
        state.graph.gOverlays = svg.append("g").attr("class", "overlays");
        state.graph.gLinks = svg.append("g").attr("class", "links");
        state.graph.gNodes = svg.append("g").attr("class", "nodes");
        state.graph.gEmpty = svg.append("g").attr("class", "empty");
      }

      function resetGraphLayers() {
        state.graph.gOverlays.selectAll("*").remove();
        state.graph.gLinks.selectAll("*").remove();
        state.graph.gNodes.selectAll("*").remove();
        state.graph.gEmpty.selectAll("*").remove();
      }

      function setGraphLegend(mode, map = null) {
        if (mode === "hypothesis") {
          els.graphDescription.textContent = "Hypothesis Map: hypothesis blocks connect to evidence as supports (green) or contradicts (red). Unassigned evidence forms candidate clusters.";
          const legend = map?.status_legend || {};
          els.graphLegend.innerHTML = `
            <span class="legend-dot" style="color:#14c985;">supports (LLM)</span>
            <span class="legend-dot" style="color:#338df5;">supports (heuristic)</span>
            <span class="legend-dot" style="color:#d43f35;">contradicts</span>
            <span class="legend-dot" style="color:#338df5;">hypothesis node</span>
            <span class="legend-dot" style="color:#5d4037;">candidate cluster</span>
            <span class="pill">untested ${legend.untested || 0}</span>
            <span class="pill">exploring ${legend.exploring || 0}</span>
            <span class="pill">confirmed ${legend.confirmed || 0}</span>
            <span class="pill">challenged ${legend.challenged || 0}</span>
            <span class="pill">saturated ${legend.saturated || 0}</span>
          `;
          return;
        }
        els.graphDescription.textContent = "Evidence Network: each node is evidence, links appear for similarity >= 0.70 (proposition/tags/FMO overlap).";
        els.graphLegend.innerHTML = `
          <span class="legend-dot" style="color:#14c985;">confirmed overlay</span>
          <span class="legend-dot" style="color:#ffca28;">exploring overlay</span>
          <span class="legend-dot" style="color:#d43f35;">challenged overlay</span>
          <span class="legend-dot" style="color:#9ca3af;">weak/merged overlay</span>
        `;
      }

      function buildEvidenceNetworkData(project, width, height) {
        const evidence = (project.evidence_store || []).map((item) => ({ ...item }));
        const propositions = project.proposition_store || [];
        const propositionMap = new Map(propositions.map((p) => [p.id, p]));

        const evidenceToProps = new Map(evidence.map((e) => [e.id, new Set()]));
        for (const prop of propositions) {
          for (const id of [...(prop.supporting_evidence || []), ...(prop.contradicting_evidence || [])]) {
            if (evidenceToProps.has(id)) evidenceToProps.get(id).add(prop.id);
          }
        }

        const nodes = evidence.map((evidenceItem) => {
          const existing = state.graph.nodePositions.get(evidenceItem.id);
          const interviewIndex = Number(String(evidenceItem.interview_id || "").replace(/\D/g, "")) || 1;
          return {
            id: evidenceItem.id,
            type: "evidence",
            interviewId: evidenceItem.interview_id,
            quote: evidenceItem.quote_english || evidenceItem.quote || "Translation pending",
            factor: evidenceItem.factor,
            mechanism: evidenceItem.mechanism,
            outcome: evidenceItem.outcome,
            tags: new Set((evidenceItem.tags || []).map((tag) => String(tag).toLowerCase())),
            fmoTokens: tokenize(`${evidenceItem.factor} ${evidenceItem.mechanism} ${evidenceItem.outcome}`),
            propositionIds: evidenceToProps.get(evidenceItem.id) || new Set(),
            interviewColor: d3.interpolateTurbo((interviewIndex % 10) / 10),
            degree: 0,
            x: existing ? existing.x : width / 2 + (Math.random() - 0.5) * 80,
            y: existing ? existing.y : height / 2 + (Math.random() - 0.5) * 80,
            vx: existing ? existing.vx : 0,
            vy: existing ? existing.vy : 0,
          };
        });

        const edges = [];
        for (let i = 0; i < nodes.length; i += 1) {
          for (let j = i + 1; j < nodes.length; j += 1) {
            const a = nodes[i];
            const b = nodes[j];
            const propositionOverlap = jaccard(a.propositionIds, b.propositionIds);
            const tagOverlap = jaccard(a.tags, b.tags);
            const fmoOverlap = jaccard(a.fmoTokens, b.fmoTokens);
            const score = 0.45 * propositionOverlap + 0.35 * tagOverlap + 0.20 * fmoOverlap;
            if (score >= 0.7) {
              edges.push({ source: a.id, target: b.id, score, propositionOverlap, tagOverlap, fmoOverlap, relation: "similarity" });
              a.degree += 1;
              b.degree += 1;
            }
          }
        }

        const radiusScale = d3.scaleLinear().domain([0, Math.max(1, d3.max(nodes, (node) => node.degree) || 1)]).range([8, 16]);
        for (const node of nodes) node.r = radiusScale(node.degree);

        return { nodes, edges, propositionMap };
      }

      function renderEmptyGraph(message) {
        const width = els.graph.clientWidth || 900;
        const height = els.graph.clientHeight || 520;
        resetGraphLayers();
        state.graph.gEmpty
          .append("text")
          .attr("x", width / 2)
          .attr("y", height / 2)
          .attr("text-anchor", "middle")
          .attr("fill", "#6b7280")
          .attr("font-size", "14")
          .text(message);
      }

      function renderHypothesisMap(project) {
        const map = state.hypothesisMap;
        if (!map || !Array.isArray(map.nodes)) {
          renderEmptyGraph("Hypothesis map is not available yet.");
          els.graphSummary.textContent = "Hypothesis model unavailable.";
          els.selectedEvidence.innerHTML = '<div class="mini-card">No node selected.</div>';
          els.overlayList.innerHTML = '<div class="mini-card">No map details yet.</div>';
          return;
        }

        const width = els.graph.clientWidth || 900;
        const height = els.graph.clientHeight || 520;
        state.graph.svg.attr("viewBox", `0 0 ${width} ${height}`);
        resetGraphLayers();

        const nodes = map.nodes.map((item) => {
          const existing = state.graph.nodePositions.get(item.id);
          return {
            ...item,
            x: existing ? existing.x : width / 2 + (Math.random() - 0.5) * 120,
            y: existing ? existing.y : height / 2 + (Math.random() - 0.5) * 120,
            vx: existing ? existing.vx : 0,
            vy: existing ? existing.vy : 0,
          };
        });
        const nodeById = new Map(nodes.map((node) => [node.id, node]));
        const edges = (map.edges || []).map((edge, idx) => ({ ...edge, id: `${edge.source}-${edge.target}-${idx}` }));

        state.graph.nodeById = nodeById;
        state.graph.edges = edges;

        const activeNodes = nodes.filter((node) => node.type === "hypothesis" || node.type === "evidence" || node.type === "candidate_cluster");
        if (!activeNodes.length) {
          renderEmptyGraph("No hypotheses/evidence available yet.");
          return;
        }

        if (!state.graph.selectedNodeId || !nodeById.has(state.graph.selectedNodeId)) {
          state.graph.selectedNodeId = activeNodes[0].id;
        }

        const simulation = d3
          .forceSimulation(nodes)
          .force("link", d3.forceLink(edges).id((d) => d.id).distance((d) => (d.relation === "potential_supporter" ? 130 : 95)).strength(0.35))
          .force("charge", d3.forceManyBody().strength(-220))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("x", d3.forceX((d) => (d.type === "hypothesis" ? width * 0.24 : d.type === "candidate_cluster" ? width * 0.5 : width * 0.74)).strength(0.32))
          .force("y", d3.forceY(height / 2).strength(0.06))
          .force("collide", d3.forceCollide().radius((d) => (d.type === "hypothesis" ? 34 : d.type === "candidate_cluster" ? 28 : 20)));

        state.graph.simulation = simulation;

        const link = state.graph.gLinks
          .selectAll("line")
          .data(edges, (d) => d.id)
          .join("line")
          .attr("stroke", (d) => {
            if (d.relation === "supports" && d.source_type === "heuristic") return "#338df5";
            if (d.relation === "supports") return "#14c985";
            if (d.relation === "contradicts") return "#d43f35";
            if (d.relation === "potential_supporter") return "#7a7a7a";
            return "#338df5";
          })
          .attr("stroke-width", (d) => (d.relation === "potential_supporter" ? 1.2 : 1.8))
          .attr("stroke-opacity", (d) => (d.relation === "potential_supporter" ? 0.45 : 0.85))
          .attr("stroke-dasharray", (d) => {
            if (d.source_type === "heuristic" || d.relation === "potential_supporter") return "5,5";
            if (d.relation === "candidate_member") return "3,4";
            return "";
          });

        const nodeGroup = state.graph.gNodes
          .selectAll("g.node")
          .data(nodes, (d) => d.id)
          .join((enter) => {
            const g = enter.append("g").attr("class", "node").style("cursor", "pointer");
            g.append("rect").attr("rx", 10).attr("ry", 10);
            g.append("circle");
            g.append("text").attr("text-anchor", "middle").attr("font-size", 10).attr("font-weight", 700).attr("pointer-events", "none");
            return g;
          });

        nodeGroup.each(function (d) {
          const g = d3.select(this);
          const rect = g.select("rect");
          const circle = g.select("circle");
          const text = g.select("text");

          if (d.type === "hypothesis") {
            rect
              .attr("display", null)
              .attr("x", -48)
              .attr("y", -18)
              .attr("width", 96)
              .attr("height", 36)
              .attr("fill", "#e8f3ff")
              .attr("stroke", d.id === state.graph.selectedNodeId ? "#0d4a95" : "#338df5")
              .attr("stroke-width", d.id === state.graph.selectedNodeId ? 2.2 : 1.4);
            circle.attr("display", "none");
            text.attr("fill", "#0d4a95").text(d.id);
          } else if (d.type === "candidate_cluster") {
            rect.attr("display", "none");
            circle
              .attr("display", null)
              .attr("r", 16)
              .attr("fill", "#fff2e8")
              .attr("stroke", d.id === state.graph.selectedNodeId ? "#5d4037" : "#b78363")
              .attr("stroke-width", d.id === state.graph.selectedNodeId ? 2.2 : 1.4)
              .attr("stroke-dasharray", "4,3");
            text.attr("fill", "#5d4037").text(d.id.replace("CLUSTER_", "C"));
          } else {
            rect.attr("display", "none");
            circle
              .attr("display", null)
              .attr("r", 13)
              .attr("fill", "#fff")
              .attr("stroke", d.id === state.graph.selectedNodeId ? "#23262c" : "#6b7280")
              .attr("stroke-width", d.id === state.graph.selectedNodeId ? 2.2 : 1.2);
            text.attr("fill", "#23262c").text(d.id);
          }
        });

        nodeGroup.selectAll("title").remove();
        nodeGroup.append("title").text((d) => `${d.id}\n${d.label || ""}`);

        nodeGroup.on("click", (_, node) => {
          state.graph.selectedNodeId = node.id;
          renderHypothesisMap(project);
        });

        simulation.on("tick", () => {
          link
            .attr("x1", (d) => (nodeById.get(d.source.id || d.source) || {}).x)
            .attr("y1", (d) => (nodeById.get(d.source.id || d.source) || {}).y)
            .attr("x2", (d) => (nodeById.get(d.target.id || d.target) || {}).x)
            .attr("y2", (d) => (nodeById.get(d.target.id || d.target) || {}).y);

          nodeGroup.attr("transform", (d) => `translate(${d.x},${d.y})`);

          for (const node of nodes) {
            state.graph.nodePositions.set(node.id, { x: node.x, y: node.y, vx: node.vx, vy: node.vy });
          }
        });

        const stats = map.stats || {};
        els.graphSummary.textContent = `Hypotheses: ${stats.hypotheses || 0}. Evidence: ${stats.evidence || 0}. LLM supports: ${stats.supports_edges || 0}. Heuristic supports: ${stats.heuristic_supports_edges || 0}. Contradicts: ${stats.contradicts_edges || 0}. Validated: ${stats.validated_hypotheses || 0}. Unvalidated: ${stats.unvalidated_hypotheses || 0}.`;

        renderSelectedHypothesisNode(map, state.graph.selectedNodeId);
        renderHypothesisDetails(map);
      }

      function renderSelectedHypothesisNode(map, nodeId) {
        const node = (map.nodes || []).find((item) => item.id === nodeId);
        if (!node) {
          els.selectedEvidence.innerHTML = '<div class="mini-card">Click a node to inspect details.</div>';
          return;
        }

        if (node.type === "hypothesis") {
          const linked = (map.edges || []).filter((edge) => edge.source === node.id || edge.target === node.id);
          const supportEdges = linked.filter((edge) => edge.relation === "supports" && edge.source === node.id);
          const topEvidence = supportEdges
            .slice(0, 3)
            .map((edge) => {
              const evidence = (map.nodes || []).find((item) => item.id === edge.target);
              if (!evidence) return null;
              return `<div class="mini-card"><strong>${escapeHtml(evidence.id)}</strong><br/>${escapeHtml(evidence.display_quote_en || evidence.label || "")}<br/><span class="muted">${escapeHtml(edge.explanation || "")}</span></div>`;
            })
            .filter(Boolean)
            .join("");

          els.selectedEvidence.innerHTML = `
            <div class="mini-card"><strong>${escapeHtml(node.id)}</strong><br/>${escapeHtml(node.label || "")}</div>
            <div class="mini-card"><strong>F-M-O</strong><br/>${escapeHtml(node.fmo?.factor || "")} -> ${escapeHtml(node.fmo?.mechanism || "")} -> ${escapeHtml(node.fmo?.outcome || "")}</div>
            <div class="mini-card">status: ${escapeHtml(node.status || "")}, confidence: ${toPct(node.confidence || 0)}</div>
            <div class="mini-card">confirmed supports: ${node.support_count || 0}, contradicts: ${node.contradict_count || 0}, heuristic supports: ${node.heuristic_support_count || 0}</div>
            ${topEvidence || '<div class="mini-card">No linked evidence yet for this hypothesis.</div>'}
          `;
          return;
        }

        if (node.type === "candidate_cluster") {
          els.selectedEvidence.innerHTML = `
            <div class="mini-card"><strong>${escapeHtml(node.id)}</strong><br/>${escapeHtml(node.label || "")}</div>
            <div class="mini-card">members: ${node.size || 0}</div>
            <div class="mini-card">candidate cluster from unassigned evidence (read-only).</div>
          `;
          return;
        }

        const mapped = Array.isArray(node.mapped_hypotheses) ? node.mapped_hypotheses.join(", ") : "none";
        const evidenceEdges = (map.edges || []).filter((edge) => edge.target === node.id);
        const explainLines = evidenceEdges
          .slice(0, 4)
          .map((edge) => `${edge.source} (${edge.source_type}): ${edge.explanation || edge.relation}`)
          .join("<br/>");
        els.selectedEvidence.innerHTML = `
          <div class="mini-card"><strong>${escapeHtml(node.id)}</strong><br/>interview: ${escapeHtml(node.interview_id || "unknown")}</div>
          <div class="mini-card"><strong>Quote (EN)</strong><br/>${escapeHtml(node.display_quote_en || node.label || "Translation pending")}</div>
          <div class="mini-card"><strong>F-M-O</strong><br/>${escapeHtml(node.factor || "")} -> ${escapeHtml(node.mechanism || "")} -> ${escapeHtml(node.outcome || "")}</div>
          <div class="mini-card">mapped hypotheses: ${escapeHtml(mapped || "none")}</div>
          <div class="mini-card"><strong>Why linked</strong><br/>${explainLines || "No link explanation yet."}</div>
        `;
      }

      function renderHypothesisDetails(map) {
        const clusters = map.clusters || [];
        const pool = map.unassigned_pool || [];
        const progress = map.progress_snapshot || {};
        const unvalidated = map.unvalidated_hypotheses || [];

        const progressCard = `
          <div class="mini-card"><strong>Progress</strong><br/>
            new hypotheses (latest interview): ${progress.new_hypotheses_latest_interview || 0}<br/>
            total hypotheses: ${progress.total_hypotheses || 0}<br/>
            validated: ${progress.validated_hypotheses || 0}<br/>
            unvalidated: ${progress.unvalidated_hypotheses || 0}
          </div>
        `;

        const backlog = unvalidated.length
          ? unvalidated
              .slice(0, 8)
              .map(
                (item) =>
                  `<div class="mini-card"><strong>${escapeHtml(item.id)}</strong> ${escapeHtml(item.label || "")}<br/>status: ${escapeHtml(item.status || "")}, confidence: ${toPct(item.confidence || 0)}<br/>born INT_${String(item.first_seen_interview || 0).padStart(3, "0")}, updated INT_${String(item.last_updated_interview || 0).padStart(3, "0")}</div>`
              )
              .join("")
          : '<div class="mini-card">All hypotheses have at least one confirmed link.</div>';

        const clusterHtml = clusters.length
          ? clusters
              .slice(0, 5)
              .map((cluster) => {
                const supporters = (cluster.potential_supporters || []).map((item) => `${item.evidence_id} (${item.score})`).join(", ");
                return `<div class="mini-card"><strong>${escapeHtml(cluster.id)}</strong>: ${escapeHtml(cluster.label || "")}<br/>members: ${(cluster.evidence_ids || []).length}<br/>potential supporters: ${escapeHtml(supporters || "none")}</div>`;
              })
              .join("")
          : '<div class="mini-card">No candidate clusters yet.</div>';

        els.overlayList.innerHTML = `
          ${progressCard}
          <div class="mini-card"><strong>Unvalidated hypotheses backlog</strong><br/>${unvalidated.length}</div>
          ${backlog}
          <div class="mini-card"><strong>Candidate clusters</strong><br/>${clusters.length}</div>
          ${clusterHtml}
          <div class="mini-card"><strong>Unassigned evidence pool</strong><br/>${pool.length}</div>
        `;
      }

      function renderEvidenceNetwork(project) {
        const width = els.graph.clientWidth || 900;
        const height = els.graph.clientHeight || 520;
        state.graph.svg.attr("viewBox", `0 0 ${width} ${height}`);

        const { nodes, edges, propositionMap } = buildEvidenceNetworkData(project, width, height);
        state.graph.nodeById = new Map(nodes.map((node) => [node.id, node]));
        state.graph.edges = edges;

        if (!nodes.length) {
          renderEmptyGraph("No evidence yet. Complete interviews to populate this map.");
          state.graph.selectedNodeId = null;
          els.selectedEvidence.innerHTML = '<div class="mini-card">No node selected.</div>';
          els.overlayList.innerHTML = '<div class="mini-card">No hypotheses yet.</div>';
          els.graphSummary.textContent = "No evidence yet. Node and edge metrics will appear after first webhook ingestion.";
          return;
        }

        resetGraphLayers();

        if (!state.graph.selectedNodeId || !state.graph.nodeById.has(state.graph.selectedNodeId)) {
          state.graph.selectedNodeId = nodes[0].id;
        }

        const simulation = d3
          .forceSimulation(nodes)
          .force("link", d3.forceLink(edges).id((d) => d.id).distance(95).strength(0.36))
          .force("charge", d3.forceManyBody().strength(-180))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collide", d3.forceCollide().radius((d) => d.r + 8))
          .alpha(0.9)
          .restart();

        state.graph.simulation = simulation;

        const links = state.graph.gLinks
          .selectAll("line")
          .data(edges, (d) => `${d.source.id || d.source}-${d.target.id || d.target}`)
          .join("line")
          .attr("stroke", "#95a0ad")
          .attr("stroke-opacity", 0.34)
          .attr("stroke-width", (d) => 1 + d.score * 2.1)
          .attr("stroke-dasharray", "5,5");

        const nodeGroups = state.graph.gNodes
          .selectAll("g.node")
          .data(nodes, (d) => d.id)
          .join((enter) => {
            const group = enter.append("g").attr("class", "node").style("cursor", "pointer");
            group.append("circle");
            group.append("text").attr("text-anchor", "middle").attr("dy", 4).attr("font-size", 10).attr("font-weight", 700).attr("pointer-events", "none");
            return group;
          });

        nodeGroups
          .select("circle")
          .attr("fill", (d) => d.interviewColor)
          .attr("r", (d) => d.r)
          .attr("stroke", (d) => (d.id === state.graph.selectedNodeId ? "#23262c" : "#ffffff"))
          .attr("stroke-width", (d) => (d.id === state.graph.selectedNodeId ? 2.2 : 1.3));

        nodeGroups.select("text").attr("fill", "#23262c").text((d) => d.id);

        nodeGroups.selectAll("title").remove();
        nodeGroups.append("title").text((d) => `${d.id}\n${d.quote}`);

        const overlaysData = (project.proposition_store || []).map((proposition) => ({ proposition, evidenceIds: proposition.supporting_evidence || [] }));

        const overlays = state.graph.gOverlays
          .selectAll("path")
          .data(overlaysData, (item) => item.proposition.id)
          .join("path")
          .attr("fill", (item) => propositionColor(item.proposition))
          .attr("fill-opacity", 0.09)
          .attr("stroke", (item) => propositionColor(item.proposition))
          .attr("stroke-opacity", 0.34)
          .attr("stroke-width", 1.2);

        nodeGroups.on("click", (_, node) => {
          state.graph.selectedNodeId = node.id;
          renderEvidenceNetwork(project);
        });

        simulation.on("tick", () => {
          links
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          nodeGroups.attr("transform", (d) => `translate(${d.x},${d.y})`);

          const nodeById = new Map(nodes.map((node) => [node.id, node]));
          overlays.attr("d", (item) => {
            const points = item.evidenceIds.map((id) => nodeById.get(id)).filter(Boolean).map((node) => [node.x, node.y]);
            if (!points.length) return "";
            if (points.length === 1) {
              const [x, y] = points[0];
              const r = 21;
              return `M ${x - r},${y} a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 ${-r * 2},0`;
            }
            if (points.length === 2) {
              const cx = (points[0][0] + points[1][0]) / 2;
              const cy = (points[0][1] + points[1][1]) / 2;
              const dx = points[0][0] - points[1][0];
              const dy = points[0][1] - points[1][1];
              const r = Math.max(18, Math.sqrt(dx * dx + dy * dy) / 2 + 10);
              return `M ${cx - r},${cy} a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 ${-r * 2},0`;
            }
            const hull = d3.polygonHull(points);
            if (!hull) return "";
            return `M ${hull.map((p) => `${p[0]},${p[1]}`).join(" L ")} Z`;
          });

          for (const node of nodes) {
            state.graph.nodePositions.set(node.id, { x: node.x, y: node.y, vx: node.vx, vy: node.vy });
          }
        });

        const selected = state.graph.nodeById.get(state.graph.selectedNodeId) || nodes[0];
        renderSelectedNetworkNode(selected, propositionMap);
        renderNetworkMapDetails(project);
        els.graphSummary.textContent = `Evidence nodes: ${nodes.length}. Similarity edges: ${edges.length}. Threshold: 0.70.`;
      }

      function renderSelectedNetworkNode(node, propositionMap) {
        if (!node) {
          els.selectedEvidence.innerHTML = '<div class="mini-card">No node selected.</div>';
          return;
        }
        const linkedProps = Array.from(node.propositionIds || []).map((id) => propositionMap.get(id)).filter(Boolean);
        const propsText = linkedProps.length ? linkedProps.map((prop) => `${prop.id} (${prop.status}, ${toPct(prop.confidence)})`).join("<br/>") : "none";

        els.selectedEvidence.innerHTML = `
          <div class="mini-card"><strong>${escapeHtml(node.id)}</strong><br/>interview: ${escapeHtml(node.interviewId || "unknown")}<br/>degree: ${node.degree}</div>
          <div class="mini-card"><strong>Quote</strong><br/>${escapeHtml(node.quote || "")}</div>
          <div class="mini-card"><strong>F-M-O</strong><br/>${escapeHtml(node.factor || "")} -> ${escapeHtml(node.mechanism || "")} -> ${escapeHtml(node.outcome || "")}</div>
          <div class="mini-card"><strong>Linked hypotheses</strong><br/>${propsText}</div>
        `;
      }

      function renderNetworkMapDetails(project) {
        const propositions = project.proposition_store || [];
        if (!propositions.length) {
          els.overlayList.innerHTML = '<div class="mini-card">No hypotheses yet.</div>';
          return;
        }
        els.overlayList.innerHTML = propositions
          .slice(0, 12)
          .map((prop) => {
            const color = propositionColor(prop);
            return `<div class="mini-card" style="border-left:4px solid ${color};"><strong>${escapeHtml(prop.id)}</strong> - ${escapeHtml(prop.status)} - conf ${toPct(prop.confidence)}<br/><span class="muted">${escapeHtml(prop.factor || "")}</span><br/>support ${prop.supporting_evidence?.length || 0} / contradict ${prop.contradicting_evidence?.length || 0}</div>`;
          })
          .join("");
      }

      function renderGraph(project) {
        ensureGraphInitialized();
        setGraphLegend(state.visualMode, state.hypothesisMap);
        if (state.visualMode === "hypothesis") {
          renderHypothesisMap(project);
          return;
        }
        renderEvidenceNetwork(project);
      }

      function parseMarkdownSections(markdown) {
        const lines = String(markdown || "").split("\n");
        const sections = [];
        let current = { title: "Overview", body: [] };
        for (const line of lines) {
          const h2 = line.match(/^##\s+(.+)/);
          const h3 = line.match(/^###\s+(.+)/);
          if (h2 || h3) {
            if (current.body.length) sections.push({ title: current.title, body: current.body.join("\n").trim() });
            current = { title: (h2 || h3)[1].trim(), body: [] };
          } else {
            current.body.push(line);
          }
        }
        if (current.body.length) sections.push({ title: current.title, body: current.body.join("\n").trim() });
        return sections.filter((item) => item.body);
      }

      function renderReport(project) {
        if (!project.report_markdown) {
          const staleText = project.report_stale ? " (stale)" : "";
          setStatus(els.reportStatus, `No report yet. Project status: ${project.status}${staleText}`);
          els.reportView.innerHTML = "";
          return;
        }

        const generatedAt = project.report_generated_at || "unknown";
        const staleText = project.report_stale ? " - stale" : "";
        const mode = project.report_generation_mode || "unknown";
        const reason = project.report_fallback_reason ? ` | fallback reason: ${project.report_fallback_reason}` : "";
        setStatus(els.reportStatus, `Report generated: ${generatedAt}${staleText} | mode: ${mode}${reason}`);

        if (els.rawToggle.checked) {
          els.reportView.innerHTML = `<pre class="mono">${escapeHtml(project.report_markdown)}</pre>`;
          return;
        }

        const sections = parseMarkdownSections(project.report_markdown);
        els.reportView.innerHTML = sections
          .map((section, index) => `
            <details ${index === 0 ? "open" : ""}>
              <summary>${escapeHtml(section.title)}</summary>
              <div class="mono" style="white-space:pre-wrap; overflow-wrap:anywhere; margin-top:8px; line-height:1.5;">${escapeHtml(section.body)}</div>
            </details>
          `)
          .join("");
      }

      function scheduleProjectRefresh() {
        if (!state.selectedProjectId) return;
        if (state.refreshDebounce) clearTimeout(state.refreshDebounce);
        state.refreshDebounce = setTimeout(async () => {
          await loadProject(state.selectedProjectId, { silent: true });
          await refreshCards({ silent: true });
        }, 350);
      }

      function disconnectSSE() {
        if (state.sse) state.sse.close();
        state.sse = null;
        state.sseConnected = false;
      }

      function connectSSE(projectId) {
        if (!projectId) return;
        disconnectSSE();

        const source = new EventSource(`/api/projects/${encodeURIComponent(projectId)}/stream`);
        state.sse = source;

        source.onopen = () => {
          state.sseConnected = true;
        };

        source.onerror = () => {
          state.sseConnected = false;
        };

        [
          "new_evidence",
          "proposition_updated",
          "new_proposition",
          "script_updated",
          "project_status",
          "project_stats",
          "report_ready",
          "report_stale",
          "prompt_sanitized",
          "topic_redirect_applied",
          "visualization_model_ready",
          "translations_backfilled",
          "heuristic_links_updated",
        ].forEach((eventName) => source.addEventListener(eventName, () => scheduleProjectRefresh()));
      }

      function ensurePollingFallback() {
        if (state.pollingTimer) return;
        state.pollingTimer = setInterval(async () => {
          if (!state.selectedProjectId || state.sseConnected) return;
          await loadProject(state.selectedProjectId, { silent: true });
          await refreshCards({ silent: true });
        }, 10000);
      }

      function ensureCardsRefreshLoop() {
        if (state.cardsTimer) return;
        state.cardsTimer = setInterval(async () => {
          await refreshCards({ silent: true });
        }, 15000);
      }

      async function createProject() {
        const researchQuestion = els.researchQuestion.value.trim();
        if (!researchQuestion) {
          setStatus(els.createStatus, "Research question is required.", true);
          return;
        }

        await runAction({
          button: els.createProjectBtn,
          statusEl: els.createStatus,
          actionName: "Create project",
          fn: async () => {
            const result = await api("/api/projects", {
              method: "POST",
              body: JSON.stringify({ research_question: researchQuestion }),
            });
            setStatus(els.createStatus, `Created ${result.project_id}`);
            await refreshCards({ silent: true });
            await selectProject(result.project_id, { silent: true });
          },
        });
      }

      async function startResearch() {
        if (!state.selectedProjectId) {
          setStatus(els.controlStatus, "Select or create a project first.", true);
          return;
        }

        await runAction({
          button: els.startBtn,
          statusEl: els.controlStatus,
          actionName: "Start research",
          fn: async () => {
            const agentId = els.agentId.value.trim();
            const payload = agentId ? { elevenlabs_agent_id: agentId } : {};
            const result = await api(`/api/projects/${encodeURIComponent(state.selectedProjectId)}/start`, {
              method: "POST",
              body: JSON.stringify(payload),
            });
            setStatus(
              els.controlStatus,
              `Project started. prompt safety: ${result.prompt_safety_status || "ok"} (${result.prompt_safety_violations_count || 0}).`
            );
            await loadProject(state.selectedProjectId, { silent: true });
            await refreshCards({ silent: true });
            connectSSE(state.selectedProjectId);
          },
        });
      }

      async function finishResearch() {
        if (!state.selectedProjectId) {
          setStatus(els.controlStatus, "Select or create a project first.", true);
          return;
        }

        const project = state.selectedProject;
        if (!project || (project.interview_store || []).length === 0 || (project.evidence_store || []).length === 0) {
          setStatus(els.controlStatus, "Cannot finish yet: no ingested transcript/evidence.", true);
          return;
        }

        await runAction({
          button: els.finishBtn,
          statusEl: els.controlStatus,
          actionName: "Finish and generate report",
          fn: async () => {
            await api(`/api/projects/${encodeURIComponent(state.selectedProjectId)}/finish`, { method: "POST" });
            setStatus(els.controlStatus, "Generating report in background...");
            await loadProject(state.selectedProjectId, { silent: true });
            await refreshCards({ silent: true });
          },
        });
      }

      async function stopProject() {
        if (!state.selectedProjectId) {
          setStatus(els.controlStatus, "Select or create a project first.", true);
          return;
        }
        await runAction({
          button: els.stopBtn,
          statusEl: els.controlStatus,
          actionName: "Stop project",
          fn: async () => {
            await api(`/api/projects/${encodeURIComponent(state.selectedProjectId)}/stop`, {
              method: "POST",
            });
            setStatus(els.controlStatus, "Project stopped. Agent is now free for another project.");
            await loadProject(state.selectedProjectId, { silent: true });
            await refreshCards({ silent: true });
          },
        });
      }

      async function deleteProject() {
        if (!state.selectedProjectId) {
          setStatus(els.controlStatus, "Select or create a project first.", true);
          return;
        }
        const ok = window.confirm(`Delete project '${state.selectedProjectId}'? This cannot be undone.`);
        if (!ok) return;

        await runAction({
          button: els.deleteBtn,
          statusEl: els.controlStatus,
          actionName: "Delete project",
          fn: async () => {
            await api(`/api/projects/${encodeURIComponent(state.selectedProjectId)}`, {
              method: "DELETE",
            });
            window.location.reload();
          },
        });
      }

      async function reloadProjectState() {
        if (!state.selectedProjectId) {
          setStatus(els.controlStatus, "Select or create a project first.", true);
          return;
        }
        await runAction({
          button: els.reloadBtn,
          statusEl: els.controlStatus,
          actionName: "Reload state",
          fn: async () => {
            await loadProject(state.selectedProjectId, { silent: true });
            await refreshCards({ silent: true });
          },
        });
      }

      function openFullscreenGraph() {
        if (!state.selectedProjectId) {
          setStatus(els.controlStatus, "Select or create a project first.", true);
          return;
        }
        const url = `/ui/graph?project_id=${encodeURIComponent(state.selectedProjectId)}&mode=${encodeURIComponent(state.visualMode)}`;
        window.open(url, "_blank", "noopener,noreferrer");
      }

      function switchMode(mode) {
        state.visualMode = mode;
        els.modeHypothesisBtn.classList.toggle("active", mode === "hypothesis");
        els.modeNetworkBtn.classList.toggle("active", mode === "network");
        if (state.selectedProject) {
          renderGraph(state.selectedProject);
        }
      }

      els.createProjectBtn.onclick = createProject;
      els.startBtn.onclick = startResearch;
      els.finishBtn.onclick = finishResearch;
      els.reloadBtn.onclick = reloadProjectState;
      els.stopBtn.onclick = stopProject;
      els.deleteBtn.onclick = deleteProject;
      els.openFullscreenBtn.onclick = openFullscreenGraph;
      els.modeHypothesisBtn.onclick = () => switchMode("hypothesis");
      els.modeNetworkBtn.onclick = () => switchMode("network");
      els.rawToggle.onchange = () => {
        if (state.selectedProject) renderReport(state.selectedProject);
      };

      async function boot() {
        els.reloadBtn.disabled = true;
        els.stopBtn.disabled = true;
        els.deleteBtn.disabled = true;
        els.openFullscreenBtn.disabled = true;
        await refreshCards({ silent: true });

        if (state.selectedProjectId) {
          await selectProject(state.selectedProjectId, { silent: true });
        }

        switchMode("hypothesis");
        ensurePollingFallback();
        ensureCardsRefreshLoop();
      }

      boot();
    </script>
  </body>
</html>
